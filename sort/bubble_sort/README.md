## 冒泡排序

### 直接遍历

遍历元素集合，如果相邻两元素顺序不对（前者更大）则交换，重复操作直到集合有序。比如整型数组：`[29, 10, 14, 37, 14]`

#### 排序过程

```shell
bubble_sort $ go run main.go	# 代码注释比较清晰，可做参考
[UNSORTED]:  [29 10 14 37 14]
[DEBUG]:  [10 29 14 37 14]
[DEBUG]:  [10 14 29 37 14]
[DEBUG]:  [10 14 29 37 14]
[DEBUG]:  [10 14 29 14 37]	# 第一趟
[DEBUG]:  [10 14 29 14 37]
[DEBUG]:  [10 14 29 14 37]
[DEBUG]:  [10 14 14 29 37]	# 第二趟
[DEBUG]:  [10 14 14 29 37]
[DEBUG]:  [10 14 14 29 37]	# 第三趟
[DEBUG]:  [10 14 14 29 37]	# 第四趟
[SORTED]:  [10 14 14 29 37]
```

#### 交换效果

 ![1](http://p7f8yck57.bkt.clouddn.com/2018-06-13-025134.gif)

#### 算法复杂度

最好情况正序 `[]int{1, 2, 3, ... , n}`：**O(N^2)**

最坏情况反序 `[]int{n, ..., 3, 2, 1}`：**O(N^2)**

平均复杂度： **O(n^2)**



### 优化一：检测是否已提前有序

可看到第二趟结束数组已排序完毕，但嵌套的 `for` 循环仍在遍历第三趟、第四趟。此时可以设标志 `flag`：某趟遍历只要发生了交换则`flag = true`，从未发生交换则为 `false` 说明提前有序。

#### 排序过程

```shell
bubble_sort $ go run flag_main.go
[UNSORTED]:  [29 10 14 37 14]
[DEBUG]:  [10 29 14 37 14]
[DEBUG]:  [10 14 29 37 14]
[DEBUG]:  [10 14 29 37 14]
[DEBUG]:  [10 14 29 14 37]	# 第一趟
[DEBUG]:  [10 14 29 14 37]
[DEBUG]:  [10 14 29 14 37]
[DEBUG]:  [10 14 14 29 37]
[DEBUG]:  [10 14 14 29 37]	# 第二趟
[DEBUG]:  [10 14 14 29 37]	# 第三趟
[SORTED]:  [10 14 14 29 37]
```

检测到第 3 趟没有发生元素交换，就不再进行第 4 趟遍历。

#### 算法复杂度

最好情况正序：遍历 1 趟，比较 n-1 次。复杂度为 **O(N)**

最坏情况反序：遍历 n-1 趟，每趟比较 n-i 次。复杂度为 **O(N^2)**

平均复杂度： `O(n^2)`





### 优化二：缩短扫描距离

可记录每趟最后发生交换的位置，此位置之后均已有序，下一趟只需遍历到此位置即可。这种实现直接暴力遍历，与前两种不太一样。

#### 排序过程

```shell
bubble_sort $ go run end_main.go
[UNSORTED]:  [29 10 14 37 14]
[DEBUG]:  [10 14 29 14 37]
[DEBUG]:  [10 14 14 29 37]
[DEBUG]:  [10 14 14 29 37]
[SORTED]:  [10 14 14 29 37]
```

#### 算法复杂度

与优化一相同，平均时间复杂度为 **O(N^2)**



### 优化三：双向冒泡排序（鸡尾酒排序）

每趟向后遍历排为从低到高，再向前遍历从高到低。

#### 排序过程

```shell
bubble_sort $ go run shaker_main.go
[UNSORTED]:  [29 10 14 37 14]
[DEBUG right]:  [10 14 29 14 37]	# -> 找到最大值 37
[DEBUG left]:  [10 14 14 29 37]		# 找到最小值10 <-
[DEBUG right]:  [10 14 14 29 37]	#  -> 找到第二大值 29
[DEBUG left]:  [10 14 14 29 37]		# 找到第二小值 14 <-
[SORTED]:  [10 14 14 29 37]			# 排序完毕
```

#### 交换效果

 ![2](http://p7f8yck57.bkt.clouddn.com/2018-06-13-080814.gif)

#### 算法复杂度

最好最坏均为 **O(N ^ 2)**



### 使用场景

冒泡排序的关键是双重嵌套的循环，时间复杂度是很高的 **O(N^2)**，大多数情况下效率很低，适用于大量元素已有序的集合、少量无序元素的集合。

冒泡排序的空间复杂度为 **O(1)**，同时因为进行两两比较，相同元素间的次序不变，稳定性高。



### 总结

冒泡排序中，“泡” 就是更大或更小的值，“冒” 就是双重遍历的过程。上边四种实现都是从小到大正序排，如果要反序排将比较逻辑置为相反即可。