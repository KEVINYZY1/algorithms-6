# 插值查找

二分查找存在的问题：它取中点的逻辑是 `mid  = (left + right) / 2`，在 `[1, 2, ..., 100]` 中要寻找 3 的位置，需要找 50，24，11，5，2 才能找到 3，在这种元素值分布比较均匀的集合中，二分查找的逻辑不是很适用。

插值查找优化：在元素值分布均匀的集合中，可根据查找值与集合值范围的比例来大致算出它的位置。算式推算：

1. 计算要查找值在数组中所占比例：`rate = (v - arr[left]) / (arr[right] - arr[left])`
2. 将比例换算为距离：`distance = rate * (right - left)`
3. 加上起始位置能得出 mid 的大致位置：`mid = left + distance`

mid 取值：`mid = left + (v - arr[left]) / (arr[right] - arr[left]) * (right - left)`，一句话：用值的比例估算位置比例，得出位置

## 排序过程

```shell
insert_search git $ go run main.go	# 在 [0, 1, ..., 1000] 的数组中寻找 233
[DEBUG arr[mid]]:        232		# mid 算出来是 232 就直接找到
```

## 复杂度

### 时间复杂度

根据元素值分布均匀情况而定，平均时间复杂度 **O(log(logN))**

### 空间复杂度

递归调用借助了外部栈，空间复杂度为 **O(N)**

## 使用场景

元素个数很多、元素值分布均匀的集合。