# 斐波那契查找

关于斐波那契数列不必多说，其满足 `f(n) = f(n-1) + f(n-2)`，即：

```shell
1, 1, 2, 3, 5, 8, 13, 21 ... # 后项和为其前两项和 # 查找过程和 0.618 没有任何关系，不必纠结
```

二分查找、插值查找、斐波那契查找本质都是一样的，只是对数组的分割方式不同：

- 二分查找：每次查找都取正中点
- 插值查找：根据值大小来估计位置，动态调整中点位置
- 斐波那契查找：**只使用了加减法**，避免了二分和插值查找的除法运算，（一般来说）更快

至于斐波那契查找是怎么避免使用除法的，需要借助斐波那契数列。整个查找过程会涉及 3 个数组：

1. 待查找数组 `arr`
2. 斐波那契数组 `fbArr`
3. 根据斐波那契数列填充后的数组 `fillArr`

举个例子，在数组`arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` 中查找 8，数组长度为 10，其向上取到的斐波那契数为 13，填充后的数组为：`[0 1 2 3 4 5 6 7 8 9 9 9 9]`

整个查找过程为：

 <img src="http://p7f8yck57.bkt.clouddn.com/2018-06-20-111018.png" width=400px />

至于为什么要搞三个数组这么复杂，一句话，**<u>为了引入斐波那契数列，使用加减法代替除法</u>**。

## 查找过程

```shell
# 参考代码和上边的图示
fibonacci_search $ go run main.go            
[DEBUG left, right]:     0 10	# 在 5 区域	
[DEBUG left, right]:     8 10	# 在 3 区域
[DEBUG left, right]:     8 9	# 在 2 区域
[DEBUG left, right]:     8 8	# 查找成功
8
```

## 复杂度

### 时间复杂度

根据元素值分布均匀情况而定，平均时间复杂度 **O(logN)**

### 空间复杂度

**O(1)**

## 使用场景

有序元素集合（数组）